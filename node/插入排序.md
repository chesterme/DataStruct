## 简单插入排序
### 算法描述
1. 将一组输入数据分成两部分，一部分是已经排序的，另一部分是还没有排序的
2. 从未排序的序列中逐个取出元素，将它插入到已经排序的序列中
3. 当未排序的序列为空时，插入排序完成

### 伪代码
```java
insertSort(T[] input){
    for(int i = 1, j; i < input.length; i++){
        // input[i]为插入的元素
        T temp = input[i];
        // 假定序列[0,...,j]是已经排好序的序列
        for(j = i - 1; j >= 0; ){
            // 如果input[j] > 插入的元素，那么需要将input[j]元素向后移动一位
            if(input[j] > temp){
                input[j + 1] = input[j];
                j--;
            }
            // 如果input[j] <= 插入的元素，那么插入点就是在位置j的后面
            else{
                break;
            }
        }
        input[j + 1] = temp;
    }
}
```

### 时间复杂度
将一个元素插入到一个大小为N的有序序列中，考虑最坏情况下，需要移动N个元素，构建一个有序序列最坏情况下需要移动$\sum_{i=1}^{n-1}{i} = n*(n-1)/2$个元素，因此时间复杂度为：$0(n^2)$

### 空间复杂度
因为所有的操作都是在输入序列上完成的，所以空间复杂度为$0(1)$

## 希尔排序
### 算法描述
1. 将输入数据序列看成由多个有序的子序列来组成，初始时，由N个子序列组成
2. 划分子序列。选择一个合适的增量k，将原序列看成由k个子序组成，每个子序列的各元素之间在整个位置上相隔k个元素，即{input[0], input[k], input[2k],...}是属于同一个子序列
3. 然后在每个子序列中使用插入排序，使得每个子序列有序
4. 选择较小的增量，继续2，3步骤，直到增量为1，最后得到一个已经排好序的序列

### 伪代码
```java
// input表示输入序列，increments表示增量序列
shellSort(T[] input, int[] increments){
    // 从增量序列中逐个选择增量
    for(int i = 0; i < increments.length; i++){
        int increment = increments[i];
        // 将序列[0,..,increment-1]看作是以increment为增量的increment个子序列，在序列[increment, ..., input.length-1]中使用插入排序，使得各子序列有序
        for(int j = increment + 1, k; j < input.length; j++){
            // 选择插入元素
            T temp = input[j];
            // 将该元素插入到其子序列的合适位置中
            // [j-increment-1, j-2(increment-1), j-3(increment-1),...]是已经有序的序列
            for(k = j - increment - 1; k >= 0; ){
                if(input[k] < temp){
                    input[k + increment] = input[k];
                    k = k - increment - 1;
                }
                else{
                    break;
                }
            }
            input[k + increment + 1] = temp;
        }
    }
}
```

### 时间复杂度
待定

### 空间复杂度
不需要使用额外的辅助序列，所以空间复杂度为：$0(1)$


### 希尔排序与简单插入排序对比
假设输入序列为[10,1,5,2,6,3,7,9,0]，增量序列为[4,2,1]

使用简单插入排序的过程如下：

| 排序前 | 10   | 1    | 5    | 2    | 6    | 3    | 7    | 9    | 0    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 第1次  | 1    | 10   | 5    | 2    | 6    | 3    | 7    | 9    | 0    |
| 第2次  | 1    | 5    | 10   | 2    | 6    | 3    | 7    | 9    | 0    |
| 第3次  | 1    | 2    | 5    | 10   | 6    | 3    | 7    | 9    | 0    |
| 第4次  | 1    | 2    | 5    | 6    | 10   | 3    | 7    | 9    | 0    |
| 第5次  | 1    | 2    | 3    | 5    | 6    | 10   | 7    | 9    | 0    |
| 第6次  | 1    | 2    | 3    | 5    | 6    | 7    | 10   | 9    | 0    |
| 第7次  | 1    | 2    | 3    | 5    | 6    | 7    | 9    | 10   | 0    |
| 第8次  | 0    | 1    | 2    | 3    | 5    | 6    | 7    | 9    | 10   |



使用希尔排序的过程如下：

| 排序前                    | 10   | 1    | 5    | 2    | 6    | 3    | 7    | 9    | 0    |
| ------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 第一个增量排序后，假设为4 | 3    | 1    | 5    | 0    | 6    | 10   | 7    | 9    | 2    |
| 第二个增量排序后，假设为2 | 0    | 1    | 2    | 0    | 6    | 5    | 7    | 9    | 10   |
| 第三个增量排序后，假设为1 | 0    | 1    | 2    | 3    | 5    | 6    | 7    | 9    | 10   |


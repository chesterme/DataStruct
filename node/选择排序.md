## 简单选择排序
### 算法描述：
假定输入序列大小为N
1. 在未排序的序列中选择一个最小的元素，将其放置在已排序的序列的尾部
2. 当未排序的序列为空时，算法结束

### 伪代码描述
```Java
for(int i = 0; i < N - 1; i++){
    // 当前位i是存放当前未排序序列中最小的元素
    min = i;
    for(int j = i + 1; j < N; j++){
        // 从未排序的序列中选择最小的元素
        if(input[j] < input[min]){
            min = j;
        }
    }
    // 将最小的元素与i位置上的元素交换
    swap(input[min], input[i]);
}
```

### 时间复杂度
该算法的总比较次数为：$ \sum_{i=1}^{n-1} = n*(n-1) / 2 $，因此它的时间复杂度为：$ 0(n^2) $

### 空间复杂度
由于保存结果使用的是原来的序列，其中不新建新的辅助序列，所以空间复杂度为:$ 0(1)$

## 堆排序

### 最小堆
1. 最小堆是一棵完全二叉树，鉴于这个特性，可以使用一维数组$input$来表示一个最小堆，其中数组的第一个元素不表示任何元素
2. 假设最小堆的大小为N，其中第i个节点的父节点可以表示为$input[i/2]$，其左儿子节点可以表示为$input[2*i]$，其右儿子节点可以表示为：$input[2*i+1$
3. 最小堆中父节点的值比左右子树的所有值小，即根元素就是最小元素，这是堆序性
4. 最小堆的插入，先将插入元素添加在最小堆的后面，然后判断是否满足堆序性，如果不满足，即插入元素的值比其父节点的值小，则需要将插入元素在这棵完全二叉树中向上移动到合适的位置，这个过程就是上滤
5. 最小堆的删除，删除的是根节点元素，从根节点开始向下选择每一层左右节点中较小者，放置在其父节点上，这样的结果是根元素从上往下移动，直到叶子节点，然后删除

### 算法描述：
假定输入序列大小为N
1. 根据最小堆的特性，使用输入序列构建一个最小堆，
2. 每次从最小堆中删除最小元素，直到最小堆为空
3. 使用一个序列按顺序收集这些被删除的元素，最后该序列就是排序后的结果

### 伪代码描述
```Java
// 将input[i]元素下滤到合适的位置
// n表示最小堆的最大范围
perDown(T[] input, int i, int n){
    T temp = input[i];
    int parent = 0;
    int child = 0;
    for(parent = i; parent * 2 + 1 < n; parent = child){
        // 左节点
        child = parent * 2 + 1;
        // 选择左右节点中较小者
        if(input[child] < input[child + 1]>){
            child += 1;
        }
        // 如果需要下滤的元素temp <= input[child]，则说明已经找到合适的位置
        if(temp <= input[child]){
            break;
        }
        // 否则，下滤
        else{
            input[parent] = input[child];
        }
    }
    // 在插入点插入
    input[parent] = temp;
}

// 堆排序
heapSort(T[] input){
    // 建立最小堆
    for(int i = input.length / 2; i >= 0; i--){
        perDown(input, i, input.length);
    }
    for(int i = input.length - 1; i > 0; i--){
        // 从最小堆中删除根元素
        swap(input[0], input[i]);
        // 重置最小堆的根元素
        perDown(input, 0, i);
    }
    // 反序
    for(int i = 0; i < input.length /2; i++){
        swap(input[i], input[input.length - i - 1]);
    }
}
```

### 时间复杂度
在堆排序中，构建一个最小堆关键在于下滤操作，而下滤操作假设最坏情况下，是将根节点下滤到叶子节点，这里所花费的时间主要集中在与每一层的左右节点的比较上，一棵完全二叉树的最大高度为$log_2N + 1$，下滤一个节点的时间复杂度为$0(logN)$，因此构建一个最小堆的时间复杂度为：$0(NlogN)$

### 空间复杂度
在堆排序中，所有操作都是在输入序列的基础上完成的，所以空间复杂度为$0(1)$